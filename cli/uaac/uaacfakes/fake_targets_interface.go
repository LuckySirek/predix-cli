// This file was generated by counterfeiter
package uaacfakes

import (
	"sync"

	"github.build.ge.com/adoption/predix-cli/cli/cf"
	"github.build.ge.com/adoption/predix-cli/cli/uaac"
	"github.com/PredixDev/go-uaa-lib"
)

type FakeTargetsInterface struct {
	PrintAllStub               func()
	printAllMutex              sync.RWMutex
	printAllArgsForCall        []struct{}
	PrintCurrentStub           func()
	printCurrentMutex          sync.RWMutex
	printCurrentArgsForCall    []struct{}
	SetCurrentForIDStub        func(id int)
	setCurrentForIDMutex       sync.RWMutex
	setCurrentForIDArgsForCall []struct {
		id int
	}
	SetCurrentStub        func(url string, cfInstanceURL string, skipSslVerify bool, caCertFile string, tr *lib.TokenResponse)
	setCurrentMutex       sync.RWMutex
	setCurrentArgsForCall []struct {
		url           string
		cfInstanceURL string
		skipSslVerify bool
		caCertFile    string
		tr            *lib.TokenResponse
	}
	LookupAndSetCurrentStub        func(url string, context string) bool
	lookupAndSetCurrentMutex       sync.RWMutex
	lookupAndSetCurrentArgsForCall []struct {
		url     string
		context string
	}
	lookupAndSetCurrentReturns struct {
		result1 bool
	}
	GetCurrentStub        func() (target *uaac.Target, context *uaac.Context, instance *cf.Item)
	getCurrentMutex       sync.RWMutex
	getCurrentArgsForCall []struct{}
	getCurrentReturns     struct {
		result1 *uaac.Target
		result2 *uaac.Context
		result3 *cf.Item
	}
	LoadConfigStub        func()
	loadConfigMutex       sync.RWMutex
	loadConfigArgsForCall []struct{}
	invocations           map[string][][]interface{}
	invocationsMutex      sync.RWMutex
}

func (fake *FakeTargetsInterface) PrintAll() {
	fake.printAllMutex.Lock()
	fake.printAllArgsForCall = append(fake.printAllArgsForCall, struct{}{})
	fake.recordInvocation("PrintAll", []interface{}{})
	fake.printAllMutex.Unlock()
	if fake.PrintAllStub != nil {
		fake.PrintAllStub()
	}
}

func (fake *FakeTargetsInterface) PrintAllCallCount() int {
	fake.printAllMutex.RLock()
	defer fake.printAllMutex.RUnlock()
	return len(fake.printAllArgsForCall)
}

func (fake *FakeTargetsInterface) PrintCurrent() {
	fake.printCurrentMutex.Lock()
	fake.printCurrentArgsForCall = append(fake.printCurrentArgsForCall, struct{}{})
	fake.recordInvocation("PrintCurrent", []interface{}{})
	fake.printCurrentMutex.Unlock()
	if fake.PrintCurrentStub != nil {
		fake.PrintCurrentStub()
	}
}

func (fake *FakeTargetsInterface) PrintCurrentCallCount() int {
	fake.printCurrentMutex.RLock()
	defer fake.printCurrentMutex.RUnlock()
	return len(fake.printCurrentArgsForCall)
}

func (fake *FakeTargetsInterface) SetCurrentForID(id int) {
	fake.setCurrentForIDMutex.Lock()
	fake.setCurrentForIDArgsForCall = append(fake.setCurrentForIDArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("SetCurrentForID", []interface{}{id})
	fake.setCurrentForIDMutex.Unlock()
	if fake.SetCurrentForIDStub != nil {
		fake.SetCurrentForIDStub(id)
	}
}

func (fake *FakeTargetsInterface) SetCurrentForIDCallCount() int {
	fake.setCurrentForIDMutex.RLock()
	defer fake.setCurrentForIDMutex.RUnlock()
	return len(fake.setCurrentForIDArgsForCall)
}

func (fake *FakeTargetsInterface) SetCurrentForIDArgsForCall(i int) int {
	fake.setCurrentForIDMutex.RLock()
	defer fake.setCurrentForIDMutex.RUnlock()
	return fake.setCurrentForIDArgsForCall[i].id
}

func (fake *FakeTargetsInterface) SetCurrent(url string, cfInstanceURL string, skipSslVerify bool, caCertFile string, tr *lib.TokenResponse) {
	fake.setCurrentMutex.Lock()
	fake.setCurrentArgsForCall = append(fake.setCurrentArgsForCall, struct {
		url           string
		cfInstanceURL string
		skipSslVerify bool
		caCertFile    string
		tr            *lib.TokenResponse
	}{url, cfInstanceURL, skipSslVerify, caCertFile, tr})
	fake.recordInvocation("SetCurrent", []interface{}{url, cfInstanceURL, skipSslVerify, caCertFile, tr})
	fake.setCurrentMutex.Unlock()
	if fake.SetCurrentStub != nil {
		fake.SetCurrentStub(url, cfInstanceURL, skipSslVerify, caCertFile, tr)
	}
}

func (fake *FakeTargetsInterface) SetCurrentCallCount() int {
	fake.setCurrentMutex.RLock()
	defer fake.setCurrentMutex.RUnlock()
	return len(fake.setCurrentArgsForCall)
}

func (fake *FakeTargetsInterface) SetCurrentArgsForCall(i int) (string, string, bool, string, *lib.TokenResponse) {
	fake.setCurrentMutex.RLock()
	defer fake.setCurrentMutex.RUnlock()
	return fake.setCurrentArgsForCall[i].url, fake.setCurrentArgsForCall[i].cfInstanceURL, fake.setCurrentArgsForCall[i].skipSslVerify, fake.setCurrentArgsForCall[i].caCertFile, fake.setCurrentArgsForCall[i].tr
}

func (fake *FakeTargetsInterface) LookupAndSetCurrent(url string, context string) bool {
	fake.lookupAndSetCurrentMutex.Lock()
	fake.lookupAndSetCurrentArgsForCall = append(fake.lookupAndSetCurrentArgsForCall, struct {
		url     string
		context string
	}{url, context})
	fake.recordInvocation("LookupAndSetCurrent", []interface{}{url, context})
	fake.lookupAndSetCurrentMutex.Unlock()
	if fake.LookupAndSetCurrentStub != nil {
		return fake.LookupAndSetCurrentStub(url, context)
	} else {
		return fake.lookupAndSetCurrentReturns.result1
	}
}

func (fake *FakeTargetsInterface) LookupAndSetCurrentCallCount() int {
	fake.lookupAndSetCurrentMutex.RLock()
	defer fake.lookupAndSetCurrentMutex.RUnlock()
	return len(fake.lookupAndSetCurrentArgsForCall)
}

func (fake *FakeTargetsInterface) LookupAndSetCurrentArgsForCall(i int) (string, string) {
	fake.lookupAndSetCurrentMutex.RLock()
	defer fake.lookupAndSetCurrentMutex.RUnlock()
	return fake.lookupAndSetCurrentArgsForCall[i].url, fake.lookupAndSetCurrentArgsForCall[i].context
}

func (fake *FakeTargetsInterface) LookupAndSetCurrentReturns(result1 bool) {
	fake.LookupAndSetCurrentStub = nil
	fake.lookupAndSetCurrentReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTargetsInterface) GetCurrent() (target *uaac.Target, context *uaac.Context, instance *cf.Item) {
	fake.getCurrentMutex.Lock()
	fake.getCurrentArgsForCall = append(fake.getCurrentArgsForCall, struct{}{})
	fake.recordInvocation("GetCurrent", []interface{}{})
	fake.getCurrentMutex.Unlock()
	if fake.GetCurrentStub != nil {
		return fake.GetCurrentStub()
	} else {
		return fake.getCurrentReturns.result1, fake.getCurrentReturns.result2, fake.getCurrentReturns.result3
	}
}

func (fake *FakeTargetsInterface) GetCurrentCallCount() int {
	fake.getCurrentMutex.RLock()
	defer fake.getCurrentMutex.RUnlock()
	return len(fake.getCurrentArgsForCall)
}

func (fake *FakeTargetsInterface) GetCurrentReturns(result1 *uaac.Target, result2 *uaac.Context, result3 *cf.Item) {
	fake.GetCurrentStub = nil
	fake.getCurrentReturns = struct {
		result1 *uaac.Target
		result2 *uaac.Context
		result3 *cf.Item
	}{result1, result2, result3}
}

func (fake *FakeTargetsInterface) LoadConfig() {
	fake.loadConfigMutex.Lock()
	fake.loadConfigArgsForCall = append(fake.loadConfigArgsForCall, struct{}{})
	fake.recordInvocation("LoadConfig", []interface{}{})
	fake.loadConfigMutex.Unlock()
	if fake.LoadConfigStub != nil {
		fake.LoadConfigStub()
	}
}

func (fake *FakeTargetsInterface) LoadConfigCallCount() int {
	fake.loadConfigMutex.RLock()
	defer fake.loadConfigMutex.RUnlock()
	return len(fake.loadConfigArgsForCall)
}

func (fake *FakeTargetsInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.printAllMutex.RLock()
	defer fake.printAllMutex.RUnlock()
	fake.printCurrentMutex.RLock()
	defer fake.printCurrentMutex.RUnlock()
	fake.setCurrentForIDMutex.RLock()
	defer fake.setCurrentForIDMutex.RUnlock()
	fake.setCurrentMutex.RLock()
	defer fake.setCurrentMutex.RUnlock()
	fake.lookupAndSetCurrentMutex.RLock()
	defer fake.lookupAndSetCurrentMutex.RUnlock()
	fake.getCurrentMutex.RLock()
	defer fake.getCurrentMutex.RUnlock()
	fake.loadConfigMutex.RLock()
	defer fake.loadConfigMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeTargetsInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ uaac.TargetsInterface = new(FakeTargetsInterface)
